#' Plausible model selection using AIC and stability
#'
#' Given a multi-path forest from \code{build_paths()} and a stability vector
#' \eqn{\pi} from \code{stability()}, this function selects a small set of
#' "plausible" models that are both:
#' \enumerate{
#'   \item close to the best model in terms of AIC (within a tolerance \code{Delta}),
#'   \item built from predictors that are, on average, sufficiently stable
#'         (mean stability at least \code{tau}).
#' }
#' Optionally, highly similar models (by Jaccard overlap) can be removed, and
#' fitted model objects can be returned for prediction.
#'
#' @param forest Object returned by \code{build_paths()} (class \code{"path_forest"}).
#' @param pi Numeric vector of stability scores \eqn{\pi_j} for each predictor.
#'   Should either be named by predictor names, or have length equal to
#'   \code{ncol(x)} used in \code{build_paths()} and correspond to the same order.
#' @param Delta Numeric, AIC tolerance for plausibility:
#'   keep models with AIC \eqn{\le AIC_{\min} + \Delta}.
#' @param tau Numeric in [0, 1], threshold on average stability:
#'   keep models whose mean stability \eqn{\pi(S)} is at least \code{tau}.
#' @param jaccard_threshold Optional numeric in (0, 1). If not \code{NULL},
#'   models whose Jaccard similarity with an already-kept model exceeds this
#'   threshold are dropped as near-duplicates.
#' @param x Optional predictor data used to refit models when \code{return_fits = TRUE}.
#'   Only required if \code{return_fits = TRUE}.
#' @param y Optional response vector used to refit models when \code{return_fits = TRUE}.
#'   Only required if \code{return_fits = TRUE}.
#' @param family Model family to use when refitting: \code{"gaussian"} or \code{"binomial"}.
#'   Ignored if \code{return_fits = FALSE}.
#' @param return_fits Logical; if \code{TRUE}, refit each plausible model and
#'   include a list-column \code{fit} containing the fitted objects. Default is \code{FALSE}.
#'
#' @return A data.frame (with class \code{"plausible_models"}) containing one row
#'   per plausible model, with at least the columns:
#'   \itemize{
#'     \item \code{key}: model key (sorted variable names concatenated).
#'     \item \code{step}: forward-selection step at which the model appears.
#'     \item \code{size}: number of predictors in the model.
#'     \item \code{aic}: AIC of the model (from \code{build_paths()}).
#'     \item \code{mean_stability}: average stability score \eqn{\pi(S)}.
#'     \item \code{vars}: list-column of character vectors with predictor names.
#'   }
#'   If \code{return_fits = TRUE}, a list-column \code{fit} is added.
#'
#' @examples
#' \dontrun{
#'   set.seed(1)
#'   n <- 120; p <- 6
#'   X <- matrix(rnorm(n * p), n, p)
#'   colnames(X) <- paste0("x", 1:p)
#'   y <- X[,1] * 2 - X[,2] + rnorm(n)
#'
#'   forest <- build_paths(
#'     x = X, y = y, family = "gaussian",
#'     K = min(ncol(X), 5), eps = 1e-6, delta = 1, L = 25
#'   )
#'   stab <- stability(
#'     x = X, y = y, B = 30, resample = "bootstrap",
#'     family = "gaussian", K = 5, eps = 1e-6, delta = 1, L = 25
#'   )
#'
#'   plaus <- plausible_models(
#'     forest, pi = stab$pi,
#'     Delta = 2, tau = 0.6
#'   )
#'   plaus
#' }
#'
#' @export
plausible_models <- function(forest,
                             pi,
                             Delta = 2,
                             tau = 0.6,
                             jaccard_threshold = NULL) {

  ## ---- Basic checks ----

  if (is.null(forest$aic_by_model)) {
    stop("Argument 'forest' must be an object returned by build_paths() with aic_by_model component.")
  }

  models_df <- forest$aic_by_model

  # We assume models_df has at least columns:
  #   - key   : character key for the model
  #   - aic   : numeric AIC
  #   - vars  : list-column of character vectors of predictors
  #   - step  : step index
  if (!all(c("key", "aic", "vars") %in% names(models_df))) {
    stop("forest$aic_by_model must contain columns 'key', 'aic' and 'vars'.")
  }

  # Drop any duplicated models by key, keeping the lowest AIC version
  # (safety check; build_paths should already avoid duplicates by step).
  if (anyDuplicated(models_df$key)) {
    ord <- order(models_df$key, models_df$aic)
    models_df <- models_df[ord, , drop = FALSE]
    models_df <- models_df[!duplicated(models_df$key), , drop = FALSE]
  }

  # Compute global minimum AIC across all models in the forest
  aic_min <- min(models_df$aic)

  # Filter by AIC tolerance: keep models within Delta of best AIC
  keep_aic <- models_df$aic <= (aic_min + Delta)
  models_df <- models_df[keep_aic, , drop = FALSE]

  if (nrow(models_df) == 0L) {
    warning("No models satisfy the AIC criterion (Delta). Returning empty result.")
    out <- models_df
    class(out) <- c("plausible_models", class(out))
    return(out)
  }

  ## ---- Align stability vector pi with predictor names ----

  # Get predictor names from forest meta if available, otherwise from vars
  if (!is.null(forest$meta$var_names)) {
    var_names <- forest$meta$var_names
  } else {
    # Fallback: use sorted unique variable names across models
    var_names <- sort(unique(unlist(models_df$vars)))
  }

  p <- length(var_names)

  # Ensure pi has correct length and names
  if (!is.null(names(pi)) && all(var_names %in% names(pi))) {
    # Align by names, and reorder to var_names
    pi_named <- pi[var_names]
  } else {
    # Assume pi is in the same order as var_names
    if (length(pi) != p) {
      stop("Length of 'pi' does not match the number of predictors in the forest.")
    }
    pi_named <- pi
    names(pi_named) <- var_names
  }

  ## ---- Compute mean stability for each model ----

  # Initialize vector of mean stabilities
  mean_stab <- numeric(nrow(models_df))

  for (i in seq_len(nrow(models_df))) {
    vars_i <- models_df$vars[[i]]

    if (length(vars_i) == 0L) {
      # The empty model has no predictors; we set its mean stability to NA
      mean_stab[i] <- NA_real_
    } else {
      # Use only stable variables that exist in pi_named
      mean_stab[i] <- mean(pi_named[vars_i], na.rm = TRUE)
    }
  }

  models_df$mean_stability <- mean_stab

  # Drop empty models or those with undefined/NaN stability
  models_df <- models_df[!is.na(models_df$mean_stability), , drop = FALSE]

  # Apply tau threshold: keep models with mean_stability >= tau
  keep_tau <- models_df$mean_stability >= tau
  models_df <- models_df[keep_tau, , drop = FALSE]

  if (nrow(models_df) == 0L) {
    warning("No models satisfy the stability criterion (tau). Returning empty result.")
    out <- models_df
    class(out) <- c("plausible_models", class(out))
    return(out)
  }

  ## ---- Optional: remove near-duplicates using Jaccard similarity ----

  # Helper to compute Jaccard similarity between two sets of variables
  jaccard <- function(a, b) {
    a <- unique(a); b <- unique(b)
    inter <- length(intersect(a, b))
    union <- length(union(a, b))
    if (union == 0L) return(0)
    inter / union
  }

  if (!is.null(jaccard_threshold)) {
    if (jaccard_threshold <= 0 || jaccard_threshold >= 1) {
      stop("jaccard_threshold must be in (0, 1) if provided.")
    }

    # Sort models by AIC (best first); tie-break by larger mean_stability
    ord <- order(models_df$aic, -models_df$mean_stability)
    models_df <- models_df[ord, , drop = FALSE]

    keep_idx <- logical(nrow(models_df))
    kept_vars <- list()

    for (i in seq_len(nrow(models_df))) {
      vars_i <- models_df$vars[[i]]

      # Compare with all previously kept models
      if (length(kept_vars) == 0L) {
        keep_idx[i] <- TRUE
        kept_vars[[1]] <- vars_i
      } else {
        too_similar <- FALSE
        for (kv in kept_vars) {
          if (jaccard(vars_i, kv) > jaccard_threshold) {
            too_similar <- TRUE
            break
          }
        }
        if (!too_similar) {
          keep_idx[i] <- TRUE
          kept_vars[[length(kept_vars) + 1L]] <- vars_i
        }
      }
    }

    models_df <- models_df[keep_idx, , drop = FALSE]
  }

  if (nrow(models_df) == 0L) {
    warning("All models were removed by Jaccard similarity filtering. Returning empty result.")
    out <- models_df
    class(out) <- c("plausible_models", class(out))
    return(out)
  }

  # Reindex models with a simple model_id if desired
  models_df$model_id <- seq_len(nrow(models_df))

  # Move some columns to a nicer order
  col_order <- c(
    "model_id",
    setdiff(
      c("key", "step", "size", "aic", "mean_stability", "vars", "fit"),
      "model_id"
    )
  )
  col_order <- intersect(col_order, names(models_df))
  models_df <- models_df[, c(col_order, setdiff(names(models_df), col_order)), drop = FALSE]

  class(models_df) <- c("plausible_models", class(models_df))
  models_df
}
